<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cosmic Rift: Aether Wars</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');

        :root {
            --primary-glow: #00ffff;
            --secondary-glow: #ff00ff;
            --background-color: #0c001f;
            --text-color: #f0f8ff;
            --card-bg: #1a0537;
            --border-color: #4a00e0;
            --danger-color: #ff4141;
            --success-color: #3dff3d;
            --menu-width: 320px;
        }

        body {
            font-family: 'Orbitron', sans-serif;
            background-color: var(--background-color);
            color: var(--text-color);
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
            background-image: radial-gradient(circle, #1a0537, #0c001f 80%);
        }
        
        .screen {
            display: none;
            width: 100%;
            height: 100%;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            padding: 20px;
            box-sizing: border-box;
        }
        
        .screen.active {
            display: flex;
        }

        #account-display {
            background: rgba(0,0,0,0.3);
            border: 1px dashed var(--border-color);
            padding: 15px;
            margin-bottom: 20px;
            min-height: 50px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 10px;
            width: 100%;
            box-sizing: border-box;
        }

        /* --- Multiplayer & Form Styles --- */
        .multiplayer-container {
            text-align: center;
            padding: 40px;
            border: 2px solid var(--secondary-glow);
            box-shadow: 0 0 25px var(--secondary-glow);
            border-radius: 15px;
            background: rgba(0,0,0,0.6);
            width: 400px;
        }
        #host-id-display {
            background: var(--background-color);
            border: 1px dashed var(--primary-glow);
            padding: 10px;
            margin: 20px 0;
            font-size: 1.2em;
            color: var(--primary-glow);
            cursor: pointer;
            word-break: break-all;
        }
        #peer-id-input, .peer-id-input {
            width: 100%;
            padding: 10px;
            font-family: 'Orbitron', sans-serif;
            font-size: 1em;
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            color: var(--text-color);
            border-radius: 5px;
            margin-bottom: 15px;
            box-sizing: border-box;
        }
        #multiplayer-status, #host-status {
            height: 20px;
            margin-top: 15px;
            color: var(--success-color);
        }

        /* Menu & Game Mode Styles */
        .menu-container, .gamemode-container {
            text-align: center;
            padding: 40px;
            border: 2px solid var(--primary-glow);
            box-shadow: 0 0 25px var(--primary-glow);
            border-radius: 15px;
            background: rgba(0,0,0,0.6);
        }
        
        .menu-title, .gamemode-title {
            font-size: 3.5em;
            color: var(--primary-glow);
            text-shadow: 0 0 10px var(--primary-glow), 0 0 20px var(--secondary-glow);
            margin-bottom: 40px;
        }

        .menu-button, .gamemode-button, .game-control-btn {
            display: inline-block;
            width: 280px;
            padding: 15px 20px;
            margin: 15px auto;
            font-family: 'Orbitron', sans-serif;
            font-size: 1.2em;
            background-color: transparent;
            color: var(--primary-glow);
            border: 2px solid var(--primary-glow);
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }
        .menu-button, .gamemode-button { display: block; }
        .game-control-btn { width: auto; font-size: 1em; padding: 10px 20px; margin: 0 5px; }


        .menu-button:hover, .gamemode-button:hover, .game-control-btn:hover {
            background-color: var(--primary-glow);
            color: var(--background-color);
            box-shadow: 0 0 20px var(--primary-glow);
        }
        .menu-button:disabled {
            color: var(--danger-color);
            border-color: var(--danger-color);
            cursor: not-allowed;
            opacity: 0.5;
        }
        .menu-button:disabled:hover {
            background-color: transparent;
            box-shadow: none;
        }
        .back-button {
            border-color: var(--danger-color) !important;
            color: var(--danger-color) !important;
        }
        .back-button:hover {
            background-color: var(--danger-color) !important;
            color: var(--background-color) !important;
            box-shadow: 0 0 15px var(--danger-color) !important;
        }
        .gamemode-description {
            font-size: 0.9em;
            color: var(--text-color);
            opacity: 0.8;
            max-width: 300px;
            margin: -10px auto 20px auto;
        }

        /* Full Screen Glossary */
        #full-glossary-screen {
            flex-direction: column;
            justify-content: flex-start;
            overflow-y: auto;
        }
        #full-glossary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(130px, 1fr));
            gap: 20px;
            width: 100%;
            max-width: 1400px;
            padding: 20px;
        }
        .glossary-card {
            width: 130px; height: 190px; background-color: var(--card-bg); border: 2px solid var(--border-color);
            border-radius: 10px; display: flex; flex-direction: column;
            align-items: center; padding: 10px; box-sizing: border-box;
        }
        .glossary-card .card-effect {
            font-size: 0.75em;
        }
        #close-full-glossary-btn {
            margin-top: 20px;
            margin-bottom: 20px;
        }

        /* Main Game Styles */
        #game-screen {
            padding: 10px;
        }

        .game-container {
            width: 100%; height: 100%; max-width: 1400px; display: flex; flex-direction: column;
            justify-content: space-between; align-items: center; padding: 15px; box-sizing: border-box;
            border: 2px solid var(--primary-glow); box-shadow: 0 0 25px var(--primary-glow);
            border-radius: 15px; background: rgba(0,0,0,0.4); transition: transform 0.5s ease-in-out;
        }
        
        .game-container.menu-open {
            transform: translateX(calc(var(--menu-width) / -2));
        }

        .player-area { width: 100%; display: flex; justify-content: space-between; align-items: center; }
        .player-info, .ai-info { flex-basis: 25%; text-align: center; }
        .player-info h2, .ai-info h2 { margin: 0; text-shadow: 0 0 5px var(--text-color); font-size: 1.5em; }
        .score { font-size: 4em; font-weight: 700; text-shadow: 0 0 15px var(--primary-glow); line-height: 1.1; }
        .status-effects { font-size: 0.8em; color: var(--secondary-glow); height: 18px; margin-top: 5px; }
        .dark-matter-active { filter: blur(5px); pointer-events: none; }
        .center-area { text-align: center; flex-grow: 1; display: flex; flex-direction: column; justify-content: center; align-items: center; }
        #game-title { font-size: 2em; font-weight: 700; color: var(--primary-glow); text-shadow: 0 0 10px var(--primary-glow), 0 0 20px var(--secondary-glow); margin: 0 0 10px 0; }
        #message-area { height: 30px; font-size: 1.2em; color: var(--secondary-glow); text-shadow: 0 0 5px var(--secondary-glow); transition: all 0.3s; }
        .deck-area { display: flex; gap: 20px; margin-top: 20px; }

        .card-pile {
            width: 100px; height: 150px; border: 2px dashed var(--border-color); border-radius: 10px;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            cursor: pointer; transition: all 0.3s; position: relative;
        }
        .card-pile.disabled { cursor: not-allowed; opacity: 0.6; }
        .card-pile:not(.disabled):hover { border-color: var(--primary-glow); box-shadow: 0 0 15px var(--primary-glow); }
        .card-pile::before { content: 'DECK'; position: absolute; top: 5px; left: 0; right: 0; text-align: center; font-size: 0.8em; }
        #deck-count { font-size: 2em; margin-top: 15px; }

        .player-hand { width: 100%; height: 170px; display: flex; justify-content: center; align-items: center; gap: 15px; flex-wrap: wrap; }
        
        .card {
            width: 100px; height: 150px; background-color: var(--card-bg); border: 2px solid var(--border-color);
            border-radius: 10px; display: flex; flex-direction: column;
            align-items: center; padding: 8px; box-sizing: border-box; box-shadow: 0 0 10px rgba(0,0,0,0.5);
            transition: all 0.3s ease; cursor: pointer; position: relative;
        }
        .card:hover { transform: translateY(-10px) scale(1.05); box-shadow: 0 0 15px var(--secondary-glow); border-color: var(--secondary-glow); }
        .card.disabled { cursor: not-allowed; opacity: 0.6; }
        .card.disabled:hover { transform: none; box-shadow: 0 0 10px rgba(0,0,0,0.5); border-color: var(--border-color); }
        .card-name { font-size: 0.9em; font-weight: 700; text-align: center; flex-shrink: 0; }
        .card-type { font-size: 0.7em; font-style: italic; flex-shrink: 0; margin: 4px 0; }
        .card-effect {
            font-size: 0.75em;
            text-align: center;
            flex-grow: 1;
            overflow-y: auto;
            overflow-wrap: break-word;
            scrollbar-width: thin;
            scrollbar-color: var(--primary-glow) transparent;
        }
        .card-effect::-webkit-scrollbar { width: 5px; }
        .card-effect::-webkit-scrollbar-track { background: transparent; }
        .card-effect::-webkit-scrollbar-thumb { background-color: var(--primary-glow); border-radius: 20px; border: 1px solid var(--background-color); }

        .card.aether-shard .card-type, .glossary-card.aether-shard .card-type, .glossary-item.aether-shard .glossary-item-type { color: #00ffff; }
        .card.attack .card-type, .glossary-card.attack .card-type, .glossary-item.attack .glossary-item-type { color: #ff4141; }
        .card.defense .card-type, .glossary-card.defense .card-type, .glossary-item.defense .glossary-item-type { color: #3dff3d; }
        .card.special .card-type, .glossary-card.special .card-type, .glossary-item.special .glossary-item-type { color: #ff00ff; }
        
        .card.aether-shard, .glossary-card.aether-shard { border-color: #00ffff; }
        .card.attack, .glossary-card.attack { border-color: #ff4141; }
        .card.defense, .glossary-card.defense { border-color: #3dff3d; }
        .card.special, .glossary-card.special { border-color: #ff00ff; }

        .game-controls, .game-over-buttons { display: none; margin-top: 15px; }
        .game-controls.active, .game-over-buttons.active { display: block; }
        .game-over-button {
            padding: 10px 20px; font-family: 'Orbitron', sans-serif; font-size: 1em; background-color: transparent;
            color: var(--primary-glow); border: 2px solid var(--primary-glow); border-radius: 5px; cursor: pointer;
            transition: all 0.3s; margin: 0 10px;
        }
        .game-over-button:hover { background-color: var(--primary-glow); color: var(--background-color); box-shadow: 0 0 15px var(--primary-glow); }
        .game-control-btn:disabled { cursor: not-allowed; opacity: 0.5; background-color: transparent !important; color: var(--primary-glow) !important; box-shadow: none !important; }
        #quit-game-btn { color: var(--danger-color); border-color: var(--danger-color); }
        #quit-game-btn:hover { background-color: var(--danger-color); color: var(--background-color); box-shadow: 0 0 15px var(--danger-color); }
        
        #glossary-toggle {
            position: fixed; top: 50%; right: 0; transform: translateY(-50%) rotate(-90deg); transform-origin: bottom right;
            background-color: var(--border-color); color: var(--text-color); border: none; padding: 10px 15px;
            cursor: pointer; z-index: 1001; border-top-left-radius: 8px; border-top-right-radius: 8px;
            font-family: 'Orbitron', sans-serif; font-size: 1em; transition: all 0.5s ease-in-out;
            display: none;
        }
        #glossary-toggle.visible { display: block; }
        #glossary-toggle.open { right: var(--menu-width); }
        #glossary-toggle:hover { background-color: var(--primary-glow); color: var(--background-color); }
        
        #side-glossary {
            position: fixed; top: 0; right: calc(var(--menu-width) * -1); width: var(--menu-width); height: 100vh;
            background-color: #120029; border-left: 2px solid var(--primary-glow); box-shadow: -10px 0 25px rgba(0, 255, 255, 0.5);
            z-index: 1000; transition: right 0.5s ease-in-out; padding: 20px; box-sizing: border-box; overflow-y: auto;
            -ms-overflow-style: none; scrollbar-width: none;
        }
        #side-glossary::-webkit-scrollbar { display: none; }
        #side-glossary.open { right: 0; }
        #side-glossary h2 { text-align: center; color: var(--primary-glow); text-shadow: 0 0 10px var(--primary-glow); }
        .glossary-item { margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px dashed var(--border-color); }
        .glossary-item-name { font-size: 1.1em; font-weight: bold; color: var(--text-color); }
        .glossary-item-type { font-size: 0.8em; font-style: italic; margin-bottom: 5px; }
        .glossary-item-effect { font-size: 0.9em; }
    </style>
</head>
<body>

    <div id="menu-screen" class="screen active">
        <div class="menu-container">
            <h1 class="menu-title">Cosmic Rift</h1>
            <div id="connection-status" style="height: 20px; margin-bottom: 10px; color: var(--danger-color);"></div>

            <div id="account-section">
                </div>

            <button id="single-player-btn" class="menu-button">Single Player</button>
            <button id="multiplayer-btn" class="menu-button">Multiplayer</button>
            <button id="full-glossary-btn" class="menu-button">View All Cards</button>
        </div>
    </div>

    <div id="multiplayer-screen" class="screen">
        <div class="multiplayer-container">
            <h2 class="gamemode-title">Multiplayer</h2>
            <button id="host-game-btn" class="menu-button">Host Game</button>
            <button id="join-game-screen-btn" class="menu-button">Join Game</button>
            <button id="back-to-menu-btn" class="menu-button back-button">Back</button>
        </div>
    </div>

    <div id="join-screen" class="screen">
        <div class="multiplayer-container">
            <h2 class="gamemode-title">Join Game</h2>
            <p>Enter the Game ID from your friend:</p>
            <input type="text" id="peer-id-input" placeholder="Game ID...">
            <button id="connect-btn" class="menu-button">Connect</button>
            <div id="multiplayer-status"></div>
            <button id="back-to-multiplayer-menu-btn" class="menu-button back-button">Back</button>
        </div>
    </div>
    
    <div id="host-screen" class="screen">
        <div class="multiplayer-container">
            <h2 class="gamemode-title">Host Game</h2>
            <p>Share this Game ID with your friend:</p>
            <div id="host-id-display" title="Click to copy">Generating ID...</div>
            <p>Waiting for player to connect...</p>
            <div id="host-status"></div>
            <button id="cancel-host-btn" class="menu-button back-button">Cancel</button>
        </div>
    </div>


    <div id="gamemode-screen" class="screen">
        <div class="gamemode-container">
            <h2 class="gamemode-title">Select Mode</h2>
            <div id="gamemode-buttons-container">
                <button class="gamemode-button" data-mode="classic">Classic</button>
                <p class="gamemode-description">Hand Size: 3. A balanced set of core cards.</p>
                <button class="gamemode-button" data-mode="duelist">Duelist's Edge</button>
                <p class="gamemode-description">Hand Size: 2. A tactical mode with no chaotic cards.</p>
                <button class="gamemode-button" data-mode="gambit">Cosmic Gambit</button>
                <p class="gamemode-description">Hand Size: 4. A mode focused on hand management.</p>
                <button class="gamemode-button" data-mode="chaos">Cosmic Chaos</button>
                <p class="gamemode-description">Hand Size: Unlimited. All cards are in the deck.</p>
            </div>
            <button id="gamemode-back-btn" class="menu-button back-button" style="margin-top: 30px;">Back</button>
        </div>
    </div>

    <div id="full-glossary-screen" class="screen">
        <h1 class="menu-title">Complete Card Glossary</h1>
        <div id="full-glossary-grid"></div>
        <button id="close-full-glossary-btn" class="menu-button back-button">Back to Menu</button>
    </div>

    <div id="game-screen" class="screen">
        <div class="game-container" id="game-container">
            <div class="player-area">
                <div class="player-info">
                    <h2 id="player-name-display">Player</h2>
                    <div id="player-score" class="score">0</div>
                    <div id="player-status" class="status-effects"></div>
                </div>
                <div class="center-area">
                    <h1 id="game-title">Aether Wars</h1>
                    <div id="message-area"></div>
                    <div class="deck-area">
                        <div id="deck" class="card-pile">
                            <span id="deck-count"></span>
                        </div>
                    </div>
                    <div id="game-controls" class="game-controls">
                        <button id="end-turn-btn" class="game-control-btn">End Turn</button>
                        <button id="quit-game-btn" class="game-control-btn">Quit</button>
                    </div>
                    <div id="game-over-buttons" class="game-over-buttons">
                        <button id="play-again-btn" class="game-over-button">Play Again</button>
                        <button id="main-menu-btn" class="game-over-button">Main Menu</button>
                    </div>
                </div>
                <div class="ai-info">
                    <h2 id="opponent-name-display">Cosmic AI</h2>
                    <div id="ai-score" class="score">0</div>
                    <div id="ai-status" class="status-effects"></div>
                </div>
            </div>
            <div class="player-hand" id="player-hand"></div>
        </div>
    </div>

    <div id="signup-screen" class="screen">
        <div class="multiplayer-container">
            <h2 class="gamemode-title">Create Account</h2>
            <form id="signup-form">
                <input type="text" id="signup-username" placeholder="Username" required class="peer-id-input">
                <input type="email" id="signup-email" placeholder="Email" required class="peer-id-input">
                <input type="password" id="signup-password" placeholder="Password (min. 6 chars)" required class="peer-id-input">
                <button type="submit" class="menu-button">Sign Up</button>
            </form>
            <div id="signup-error" class="status-effects" style="color: var(--danger-color);"></div>
            <button id="signup-back-btn" class="menu-button back-button">Back</button>
        </div>
    </div>

    <div id="login-screen" class="screen">
        <div class="multiplayer-container">
            <h2 class="gamemode-title">Login</h2>
            <form id="login-form">
                <input type="email" id="login-email" placeholder="Email" required class="peer-id-input">
                <input type="password" id="login-password" placeholder="Password" required class="peer-id-input">
                <button type="submit" class="menu-button">Login</button>
            </form>
            <div id="login-error" class="status-effects" style="color: var(--danger-color);"></div>
            <button id="login-back-btn" class="menu-button back-button">Back</button>
        </div>
    </div>

    <div id="stats-screen" class="screen">
        <div class="multiplayer-container">
            <h2 class="gamemode-title">Your Stats</h2>
            <div id="stats-content" style="font-size: 1.2em; line-height: 1.8;"></div>
            <button id="stats-back-btn" class="menu-button back-button">Back</button>
        </div>
    </div>
    
    <div id="side-glossary">
        <h2>Card Glossary</h2>
        <div id="side-glossary-content"></div>
    </div>
    <button id="glossary-toggle">Cards</button>


<script type="module">
    // Firebase SDKs
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, onAuthStateChanged, signInAnonymously, createUserWithEmailAndPassword, signInWithEmailAndPassword, signOut } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, doc, setDoc, getDoc, onSnapshot, updateDoc, deleteDoc, runTransaction, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    // --- Global Firebase Instances ---
    let db, auth;
    let currentUserProfile = null; // Store logged-in user's profile data

    document.addEventListener('DOMContentLoaded', () => {
        // --- DOM ELEMENTS ---
        const screens = { 
            menu: document.getElementById('menu-screen'), 
            gamemode: document.getElementById('gamemode-screen'), 
            game: document.getElementById('game-screen'), 
            fullGlossary: document.getElementById('full-glossary-screen'),
            multiplayer: document.getElementById('multiplayer-screen'),
            host: document.getElementById('host-screen'),
            join: document.getElementById('join-screen'),
            signup: document.getElementById('signup-screen'),
            login: document.getElementById('login-screen'),
            stats: document.getElementById('stats-screen'),
        };

        const accountSection = document.getElementById('account-section');
        const signupForm = document.getElementById('signup-form');
        const loginForm = document.getElementById('login-form');
        const signupError = document.getElementById('signup-error');
        const loginError = document.getElementById('login-error');
        const signupBackBtn = document.getElementById('signup-back-btn');
        const loginBackBtn = document.getElementById('login-back-btn');
        const statsContent = document.getElementById('stats-content');
        const statsBackBtn = document.getElementById('stats-back-btn');

        const singlePlayerBtn = document.getElementById('single-player-btn');
        const multiplayerBtn = document.getElementById('multiplayer-btn');
        const fullGlossaryBtn = document.getElementById('full-glossary-btn');
        const closeFullGlossaryBtn = document.getElementById('close-full-glossary-btn');
        const hostGameBtn = document.getElementById('host-game-btn');
        const joinGameScreenBtn = document.getElementById('join-game-screen-btn');
        const backToMenuBtn = document.getElementById('back-to-menu-btn');
        const hostIdDisplay = document.getElementById('host-id-display');
        const hostStatus = document.getElementById('host-status');
        const cancelHostBtn = document.getElementById('cancel-host-btn');
        const peerIdInput = document.getElementById('peer-id-input');
        const connectBtn = document.getElementById('connect-btn');
        const multiplayerStatus = document.getElementById('multiplayer-status');
        const backToMultiplayerMenuBtn = document.getElementById('back-to-multiplayer-menu-btn');
        const gamemodeButtonsContainer = document.getElementById('gamemode-buttons-container');
        const gamemodeBackBtn = document.getElementById('gamemode-back-btn');
        const gameContainer = document.getElementById('game-container');
        const playerNameDisplay = document.getElementById('player-name-display');
        const playerScoreEl = document.getElementById('player-score'), aiScoreEl = document.getElementById('ai-score');
        const playerStatusEl = document.getElementById('player-status'), aiStatusEl = document.getElementById('ai-status');
        const opponentNameDisplay = document.getElementById('opponent-name-display');
        const messageArea = document.getElementById('message-area');
        const deckEl = document.getElementById('deck'), deckCountEl = document.getElementById('deck-count');
        const playerHandEl = document.getElementById('player-hand');
        const gameControls = document.getElementById('game-controls');
        const endTurnBtn = document.getElementById('end-turn-btn'), quitGameBtn = document.getElementById('quit-game-btn');
        const gameOverButtons = document.getElementById('game-over-buttons');
        const playAgainBtn = document.getElementById('play-again-btn'), mainMenuBtn = document.getElementById('main-menu-btn');
        const sideGlossaryEl = document.getElementById('side-glossary'), glossaryToggleBtn = document.getElementById('glossary-toggle');
        const sideGlossaryContentEl = document.getElementById('side-glossary-content');
        const fullGlossaryGridEl = document.getElementById('full-glossary-grid');
        const connectionStatusEl = document.getElementById('connection-status');

        // --- GAME STATE ---
        let deck = [], playerHand = [], aiHand = [];
        let playerScore = 0, aiScore = 0;
        let playerStatus = {}, aiStatus = {};
        let isPlayerTurn = true, playerHasDrawn = false, actionCardPlayedThisTurn = false;
        let gameIsOver = false;
        let currentGamemode = 'classic', handSizeLimit = 3;
        
        // --- MULTIPLAYER STATE ---
        let isMultiplayer = false;
        let isHost = false;
        let currentGameId = null;
        let unsubscribeFromGame = null;
        let gameDataForStats = null;

        // --- MASTER CARD DEFINITIONS ---
        const allCards = {
            aetherShards: [
                ...Array(4).fill({ name: 'Aether Shard', type: 'aether-shard', value: 2 }), ...Array(4).fill({ name: 'Aether Shard', type: 'aether-shard', value: 3 }),
                ...Array(3).fill({ name: 'Aether Shard', type: 'aether-shard', value: 4 }), ...Array(3).fill({ name: 'Aether Shard', type: 'aether-shard', value: 5 }),
                ...Array(2).fill({ name: 'Aether Shard', type: 'aether-shard', value: 6 }), ...Array(2).fill({ name: 'Aether Shard', type: 'aether-shard', value: 7 }),
                ...Array(1).fill({ name: 'Aether Shard', type: 'aether-shard', value: 8 }), ...Array(1).fill({ name: 'Aether Shard', type: 'aether-shard', value: 9 }),
            ],
            classic: [ { name: 'Blast', type: 'attack', effect: 'Reduce opponent score by 5.', action: 'attack', value: 5 }, { name: 'Shield', type: 'defense', effect: 'Block the next attack.', action: 'shield' }, { name: 'Double Draw', type: 'special', effect: 'Draw 2 cards next turn.', action: 'doubledraw' }, ],
            strategic: [ { name: 'Aether Overload', type: 'attack', effect: 'Opponent immediately draws 2 cards.', action: 'overload' }, { name: 'Shatter', type: 'attack', effect: 'Destroy opponent\'s Shield. If they have none, they lose 7 score.', action: 'shatter' }, { name: 'Aether Leach', type: 'special', effect: 'Steal 4 score from opponent.', action: 'leach', value: 4 }, { name: 'Stabilize', type: 'defense', effect: 'Next time you > 21, score becomes 15, not 0.', action: 'stabilize' }, { name: 'Sanctuary', type: 'defense', effect: 'Your score cannot be reduced for 2 turns.', action: 'sanctuary' }, { name: 'Rift Surge', type: 'special', effect: 'Set your score to 11.', action: 'surge' }, ],
            advanced: [ { name: 'Aether Siphon', type: 'attack', effect: 'Steal a random card from opponent\'s hand. If they have none, they lose 5 score.', action: 'siphon' }, { name: 'Rift Leak', type: 'attack', effect: 'Opponent loses 2 score at the start of their next 3 turns.', action: 'riftleak' }, { name: 'Phase Shift', type: 'defense', effect: 'On your next turn, you may skip your draw phase to gain 3 score.', action: 'phaseshift' }, { name: 'Dark Matter', type: 'defense', effect: 'Your score is hidden from your opponent for your next 2 turns.', action: 'darkmatter' }, { name: 'Supernova', type: 'attack', effect: 'Both players\' scores are halved (rounded down).', action: 'supernova' }, { name: 'Paradox', type: 'special', effect: 'If winning, swap score with lower player. If losing, swap with higher.', action: 'paradox' }, { name: 'Event Horizon', type: 'special', effect: 'For 3 turns, all score-reducing effects are reversed for both players.', action: 'eventhorizon' }, { name: 'Time Warp', type: 'special', effect: 'Take an extra turn after this one.', action: 'timewarp' }, { name: 'Counterspell', type: 'defense', effect: 'On opponent\'s next turn, if they attack, its effect is reflected back for 3 damage.', action: 'counterspell' }, { name: 'Gambit', type: 'special', effect: 'Discard your hand. Gain 5 score per card.', action: 'gambit' }, { name: 'Equilibrium', type: 'special', effect: 'Both scores become the average of the two.', action: 'equilibrium' }, { name: 'Singularity', type: 'special', effect: 'Reset both players\' scores to 0.', action: 'singularity' }, { name: 'Void Swap', type: 'special', effect: 'Swap scores with your opponent.', action: 'swap' }, ]
        };
        const cardPools = {
            classic: [...allCards.classic],
            duelist: [...allCards.classic, ...allCards.strategic],
            gambit: [...allCards.classic, ...allCards.strategic, ...allCards.advanced.filter(c => ['Gambit', 'Aether Siphon'].includes(c.name))],
            chaos: [].concat(...Object.values(allCards).slice(1))
        };

        // --- SCREEN MANAGEMENT ---
        function showScreen(screenName) {
            Object.values(screens).forEach(s => s.classList.remove('active'));
            if (screens[screenName]) screens[screenName].classList.add('active');
            glossaryToggleBtn.classList.toggle('visible', screenName === 'game');
        }

        // --- ACCOUNT AND STATS FUNCTIONS ---
        async function updateAccountUI(user) {
            accountSection.innerHTML = '';
            const accountDisplay = document.createElement('div');
            accountDisplay.id = 'account-display';

            if (user && !user.isAnonymous) {
                const userRef = doc(db, "users", user.uid);
                const docSnap = await getDoc(userRef);
                currentUserProfile = docSnap.exists() ? docSnap.data() : null;

                accountDisplay.innerHTML = `
                    <p>Welcome, ${currentUserProfile?.username || user.email}</p>
                    <div style="display:flex; gap:10px;">
                        <button id="view-stats-btn" class="game-control-btn" style="margin:0;">View Stats</button>
                        <button id="logout-btn" class="game-control-btn" style="margin:0;">Logout</button>
                    </div>
                `;
                accountSection.appendChild(accountDisplay);
                document.getElementById('logout-btn').addEventListener('click', () => signOut(auth));
                document.getElementById('view-stats-btn').addEventListener('click', showStats);

            } else {
                currentUserProfile = null;
                accountDisplay.innerHTML = `
                    <p>Play anonymously or log in to save stats.</p>
                    <div style="display:flex; gap:10px;">
                        <button id="show-login-btn" class="game-control-btn" style="margin:0;">Login</button>
                        <button id="show-signup-btn" class="game-control-btn" style="margin:0;">Sign Up</button>
                    </div>
                `;
                accountSection.appendChild(accountDisplay);
                document.getElementById('show-login-btn').addEventListener('click', () => showScreen('login'));
                document.getElementById('show-signup-btn').addEventListener('click', () => showScreen('signup'));
            }
        }
        
        async function createUserDocument(user, username) {
            const userRef = doc(db, "users", user.uid);
            const newProfile = {
                username: username,
                email: user.email,
                wins: 0,
                losses: 0,
                gamesPlayed: 0
            };
            await setDoc(userRef, newProfile);
            return newProfile;
        }

        function showStats() {
            if (currentUserProfile) {
                statsContent.innerHTML = `
                    <p><strong>Username:</strong> ${currentUserProfile.username}</p>
                    <p><strong>Wins:</strong> ${currentUserProfile.wins}</p>
                    <p><strong>Losses:</strong> ${currentUserProfile.losses}</p>
                    <p><strong>Games Played:</strong> ${currentUserProfile.gamesPlayed}</p>
                `;
                showScreen('stats');
            }
        }

        async function updatePlayerStats(winnerId, loserId) {
            if (!winnerId && !loserId) return; 

            try {
                await runTransaction(db, async (transaction) => {
                    if (winnerId) {
                        const winnerRef = doc(db, "users", winnerId);
                        const winnerDoc = await transaction.get(winnerRef);
                        if (winnerDoc.exists()) {
                            const newWins = (winnerDoc.data().wins || 0) + 1;
                            const newGamesW = (winnerDoc.data().gamesPlayed || 0) + 1;
                            transaction.update(winnerRef, { wins: newWins, gamesPlayed: newGamesW });
                        }
                    }
                    if (loserId) {
                        const loserRef = doc(db, "users", loserId);
                        const loserDoc = await transaction.get(loserRef);
                        if (loserDoc.exists()) {
                            const newLosses = (loserDoc.data().losses || 0) + 1;
                            const newGamesL = (loserDoc.data().gamesPlayed || 0) + 1;
                            transaction.update(loserRef, { losses: newLosses, gamesPlayed: newGamesL });
                        }
                    }
                });
                console.log("Player stats updated.");
            } catch (error) {
                console.error("Error updating stats in transaction:", error);
            }
        }

        // --- GAME SETUP & LOGIC ---
        function populateSideGlossary(mode) {
            const contentEl = sideGlossaryContentEl;
            contentEl.innerHTML = '';
            const actionCards = cardPools[mode];
            const uniqueActionCards = [...new Map(actionCards.map(c => [c.name, c])).values()];
            const shardValues = allCards.aetherShards.map(c => c.value);
            const aetherShardEntry = { name: 'Aether Shard', type: 'aether-shard', effect: `Adds a value between ${Math.min(...shardValues)} and ${Math.max(...shardValues)} to your score.` };
            const glossaryList = [...uniqueActionCards, aetherShardEntry];
            const typeOrder = { 'attack': 1, 'defense': 2, 'special': 3, 'aether-shard': 4 };
            glossaryList.sort((a,b) => (typeOrder[a.type] - typeOrder[b.type]) || a.name.localeCompare(b.name));
            glossaryList.forEach(card => {
                const itemEl = document.createElement('div');
                itemEl.classList.add('glossary-item', card.type);
                itemEl.innerHTML = `<div class="glossary-item-name">${card.name}</div><div class="glossary-item-type">${card.type.charAt(0).toUpperCase() + card.type.slice(1)}</div><div class="glossary-item-effect">${card.effect}</div>`;
                contentEl.appendChild(itemEl);
            });
        }

        function populateFullGlossary() {
            const gridEl = fullGlossaryGridEl;
            gridEl.innerHTML = '';
            const allActionCards = [].concat(...Object.values(cardPools));
            const uniqueActionCards = [...new Map(allActionCards.map(c => [c.name, c])).values()];
            const shardValues = allCards.aetherShards.map(c => c.value);
            const aetherShardEntry = { name: 'Aether Shard', type: 'aether-shard', effect: `Value: ${Math.min(...shardValues)}-${Math.max(...shardValues)}` };
            const glossaryList = [...uniqueActionCards, aetherShardEntry];
            const typeOrder = { 'attack': 1, 'defense': 2, 'special': 3, 'aether-shard': 4 };
            glossaryList.sort((a,b) => (typeOrder[a.type] - typeOrder[b.type]) || a.name.localeCompare(b.name));
            glossaryList.forEach(card => {
                const cardEl = document.createElement('div');
                cardEl.classList.add('glossary-card', card.type);
                cardEl.innerHTML = `<div class="card-name">${card.name}</div><div class="card-type">${card.type.charAt(0).toUpperCase() + card.type.slice(1)}</div><div class="card-effect">${card.effect}</div>`;
                gridEl.appendChild(cardEl);
            });
        }

        function createDeck(mode) {
            deck = [...allCards.aetherShards];
            const actionCards = cardPools[mode];
            actionCards.forEach(card => {
                const copies = (card.name === 'Shield' || card.name === 'Blast') ? 3 : 2;
                for(let i = 0; i < copies; i++) deck.push(card);
            });
            for (let i = deck.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [deck[i], deck[j]] = [deck[j], deck[i]]; }
        }

        function startGame(mode, isMultiplayerGame = false) {
            isMultiplayer = isMultiplayerGame;
            sideGlossaryEl.classList.remove('open');
            glossaryToggleBtn.classList.remove('open');
            gameContainer.classList.remove('menu-open');
            
            currentGamemode = mode;
            switch(mode) {
                case 'duelist': handSizeLimit = 2; break;
                case 'gambit': handSizeLimit = 4; break;
                case 'chaos': handSizeLimit = 99; break;
                default: handSizeLimit = 3;
            }
            
            if (isMultiplayer) {
                playAgainBtn.style.display = 'none';
            } else {
                playerNameDisplay.textContent = currentUserProfile?.username || "Player";
                opponentNameDisplay.textContent = "Cosmic AI";
                playAgainBtn.style.display = 'inline-block';
                createDeck(mode);
                resetGameState();
                showMessage("Your turn. Draw a card.");
            }
            
            populateSideGlossary(mode);
            gameControls.classList.add('active');
            gameOverButtons.classList.remove('active');
            showScreen('game');
        }
        
        function resetGameState() {
            playerScore = 0; aiScore = 0;
            playerHand = []; aiHand = [];
            playerStatus = {}; aiStatus = {};
            isPlayerTurn = true;
            playerHasDrawn = false; actionCardPlayedThisTurn = false;
            gameIsOver = false;
            updateAllUI();
        }

        function updateAllUI() { updateScores(); updateHandUI(); updateStatusEffectsUI(); }
        function updateScores() {
            playerScoreEl.textContent = playerStatus.darkmatter > 0 ? '??' : playerScore;
            aiScoreEl.textContent = aiStatus.darkmatter > 0 ? '??' : aiScore;
            playerScoreEl.classList.toggle('dark-matter-active', aiStatus.darkmatter > 0);
            aiScoreEl.classList.toggle('dark-matter-active', playerStatus.darkmatter > 0);
        }
        function updateHandUI() {
            playerHandEl.innerHTML = '';
            playerHand.forEach((card, index) => {
                const cardEl = document.createElement('div');
                cardEl.classList.add('card', card.type);
                const canPlay = isPlayerTurn && !actionCardPlayedThisTurn;
                if (!canPlay) cardEl.classList.add('disabled');
                cardEl.innerHTML = `<div class="card-name">${card.name}</div><div class="card-type">${card.type.charAt(0).toUpperCase() + card.type.slice(1)}</div><div class="card-effect">${card.effect || ''}</div>`;
                if (canPlay) {
                    cardEl.addEventListener('click', () => {
                         if (isMultiplayer) { playActionCardMP(card, index); } else { playActionCard(card, index); }
                    });
                }
                playerHandEl.appendChild(cardEl);
            });
            deckCountEl.textContent = deck.length;
        }
        function updateStatusEffectsUI() {
            const getStatusText = (status) => Object.entries(status).map(([key, value]) => {
                const formattedKey = key.charAt(0).toUpperCase() + key.slice(1);
                return value === true ? formattedKey : `${formattedKey}: ${value}`;
            }).join(', ');
            playerStatusEl.textContent = getStatusText(playerStatus);
            aiStatusEl.textContent = getStatusText(aiStatus);
        }
        function showMessage(msg, type = "game") {
            if (gameIsOver && !['player', 'ai', 'system'].includes(type)) return;
            messageArea.textContent = msg;
            messageArea.style.color = type === 'player' ? 'var(--primary-glow)' : type === 'ai' ? '#ff4141' : 'var(--secondary-glow)';
        }

        function processTurnStartEffects(isPlayer) {
            const userStatus = isPlayer ? playerStatus : aiStatus;
            if (userStatus.riftleak > 0) {
                reduceScore(isPlayer, 2);
                showMessage(`${isPlayer ? 'You' : 'Opponent'} took 2 damage from Rift Leak.`);
            }
            Object.keys(userStatus).forEach(key => {
                if (['riftleak', 'sanctuary', 'darkmatter', 'eventhorizon'].includes(key)) {
                    if (typeof userStatus[key] === 'number') {
                        userStatus[key]--;
                        if (userStatus[key] <= 0) delete userStatus[key];
                    }
                }
            });
            if (isPlayer && userStatus.phaseshift) {
                delete userStatus.phaseshift;
                playerHasDrawn = true; deckEl.classList.add('disabled');
                playerScore += 3;
                showMessage("You Phase Shifted, gaining 3 score.");
                if(!gameIsOver) endTurnBtn.disabled = false;
            }
            updateAllUI();
            checkWinCondition();
        }

        function checkWinCondition() {
            if (gameIsOver) return false;
            let winner = null;
            if (playerScore === 21) {
                showMessage("YOU CLOSED THE RIFT! YOU WIN!", "player");
                winner = 'player';
                endGame(winner);
                return true;
            }
            if (aiScore === 21) {
                showMessage("THE OPPONENT WINS. THE COSMOS IS LOST.", "ai");
                winner = 'ai';
                endGame(winner);
                return true;
            }
            return false;
        }
        
        function endGame(winner = null) {
            if (gameIsOver) return;
            gameIsOver = true;
            deckEl.style.display = 'none';
            gameControls.classList.remove('active');
            gameOverButtons.classList.add('active');

            const currentUser = auth.currentUser;
            if (currentUser && !currentUser.isAnonymous) {
                if (!isMultiplayer && winner) {
                    updatePlayerStats(winner === 'player' ? currentUser.uid : null, winner === 'ai' ? currentUser.uid : null);
                } else if (isMultiplayer && winner && gameDataForStats) {
                    const hostId = gameDataForStats.hostId;
                    const guestId = gameDataForStats.guestId;
                    if (!guestId) return; // Don't record stats if opponent leaves early
                    const winnerId = winner === '1' ? hostId : guestId;
                    const loserId = winner === '1' ? guestId : hostId;
                    updatePlayerStats(winnerId, loserId);
                }
            }
        }

        function handleScoreOverflow(isPlayer) {
            let score = isPlayer ? playerScore : aiScore;
            let status = isPlayer ? playerStatus : aiStatus;
            if (score > 21) {
                if (status.stabilized) { score = 15; delete status.stabilized; showMessage(`${isPlayer ? 'Your' : 'Opponent\'s'} Stabilizer absorbed the shock!`, isPlayer ? 'player' : 'ai');
                } else { score = 0; showMessage(`${isPlayer ? 'Your' : 'Opponent\'s'} rift destabilized! Score reset.`, isPlayer ? 'player' : 'ai'); }
                if (isPlayer) playerScore = score; else aiScore = score;
            }
            updateScores(); checkWinCondition();
        }

        function handleCardDraw(isPlayer, isLastDraw) {
            if (gameIsOver) return;
            const card = drawCard();
            if (!card) return;
            if (card.type === 'aether-shard') {
                showMessage(`${isPlayer ? "You" : "Opponent"} drew an Aether Shard worth ${card.value}.`);
                if (isPlayer) playerScore += card.value; else aiScore += card.value;
            } else {
                showMessage(`${isPlayer ? "You" : "Opponent"} drew ${card.name}.`);
                const hand = isPlayer ? playerHand : aiHand;
                if (hand.length < handSizeLimit) hand.push(card);
                else showMessage(`${isPlayer ? "Your" : "Opponent's"} hand is full! Card discarded.`);
            }
            handleScoreOverflow(isPlayer);
            if (isPlayer) updateHandUI();
            if (isPlayer && isLastDraw && !gameIsOver) endTurnBtn.disabled = false;
        }
        
        function drawCard() {
            if (deck.length === 0) { createDeck(currentGamemode); showMessage("Deck reshuffled!", "system"); }
            return deck.pop();
        }

        function reduceScore(isPlayer, amount) {
            const horizonActive = playerStatus.eventhorizon > 0 || aiStatus.eventhorizon > 0;
            if (isPlayer) { playerScore = Math.max(0, playerScore + (horizonActive ? amount : -amount)); }
            else { aiScore = Math.max(0, aiScore + (horizonActive ? amount : -amount)); }
        }

        function executeAction(card, isPlayer) {
            if (gameIsOver) return;
            const user = isPlayer ? 'You' : 'Opponent';
            const opponentStatus = isPlayer ? aiStatus : playerStatus;
            const userStatus = isPlayer ? playerStatus : aiStatus;
            showMessage(`${user} played ${card.name}!`);
            if (card.type === 'attack' && opponentStatus.counterspell) {
                 showMessage(`Counterspell reflects the attack!`);
                 reduceScore(isPlayer, 3);
                 delete opponentStatus.counterspell; updateAllUI(); return;
            }
            switch(card.action) {
                case 'attack': if (opponentStatus.sanctuary > 0) { showMessage(`Attack has no effect on Sanctuary!`); break; } if (opponentStatus.shield) { delete opponentStatus.shield; showMessage(`${user}'s attack was blocked!`); } else { reduceScore(!isPlayer, card.value); } break;
                case 'shatter': if (opponentStatus.shield) { delete opponentStatus.shield; showMessage(`Shield shattered!`); } else { reduceScore(!isPlayer, 7); } break;
                case 'siphon': const opponentHand = isPlayer ? aiHand : playerHand; if (opponentHand.length > 0) { const stolenCardIndex = Math.floor(Math.random() * opponentHand.length); const stolenCard = opponentHand.splice(stolenCardIndex, 1)[0]; if ((isPlayer ? playerHand : aiHand).length < handSizeLimit) { (isPlayer ? playerHand : aiHand).push(stolenCard); showMessage(`Stole ${stolenCard.name}!`); } else { showMessage(`Stole a card, but hand was full! Discarded.`); } } else { reduceScore(!isPlayer, 5); } break;
                case 'supernova': playerScore = Math.floor(playerScore/2); aiScore = Math.floor(aiScore/2); break;
                case 'riftleak': opponentStatus.riftleak = (opponentStatus.riftleak || 0) + 3; break;
                case 'shield': userStatus.shield = true; break;
                case 'stabilize': userStatus.stabilized = true; break;
                case 'sanctuary': userStatus.sanctuary = 2; break;
                case 'counterspell': userStatus.counterspell = true; break;
                case 'phaseshift': userStatus.phaseshift = true; showMessage("Phase Shift is active for next turn."); break;
                case 'darkmatter': opponentStatus.darkmatter = 2; break;
                case 'leach': const stolen = isPlayer ? Math.min(aiScore, card.value) : Math.min(playerScore, card.value); reduceScore(!isPlayer, stolen); if(isPlayer) playerScore += stolen; else aiScore += stolen; break;
                case 'doubledraw': userStatus.doubledraw = true; break;
                case 'overload': forceDraw(!isPlayer, 2); break;
                case 'swap': [playerScore, aiScore] = [aiScore, playerScore]; break;
                case 'surge': if (isPlayer) playerScore = 11; else aiScore = 11; break;
                case 'gambit': const hand = isPlayer ? playerHand : aiHand; const scoreGain = hand.length * 5; if (isPlayer) { playerScore += scoreGain; playerHand = []; } else { aiScore += scoreGain; aiHand = []; } break;
                case 'equilibrium': const avg = Math.round((playerScore + aiScore) / 2); playerScore = avg; aiScore = avg; break;
                case 'singularity': playerScore = 0; aiScore = 0; break;
                case 'timewarp': userStatus.extraTurn = true; break;
                case 'paradox': if (isPlayer) { if (playerScore > aiScore) [playerScore, aiScore] = [aiScore, playerScore]; } else { if (aiScore > playerScore) [playerScore, aiScore] = [aiScore, playerScore]; } break;
                case 'eventhorizon': playerStatus.eventhorizon = 3; aiStatus.eventhorizon = 3; break;
            }
            handleScoreOverflow(true); handleScoreOverflow(false);
            updateAllUI();
        }

        function forceDraw(isPlayer, numCards) {
            if (gameIsOver) return;
            for(let i=0; i < numCards; i++) { setTimeout(() => { if(gameIsOver) return; handleCardDraw(isPlayer, i === numCards - 1) }, (i + 1) * 500); }
        }

        function playerDraws() {
            if (isMultiplayer) { playerDrawsMP(); return; }
            if (gameIsOver || !isPlayerTurn || playerHasDrawn) return;
            playerHasDrawn = true;
            deckEl.classList.add('disabled');
            const draws = playerStatus.doubledraw ? 2 : 1;
            if(playerStatus.doubledraw) delete playerStatus.doubledraw;
            forceDraw(true, draws);
        }

        function playActionCard(card, index){
            if(gameIsOver || !isPlayerTurn || actionCardPlayedThisTurn) return;
            actionCardPlayedThisTurn = true;
            playerHand.splice(index, 1);
            executeAction(card, true);
            updateHandUI();
            if (!gameIsOver) endTurnBtn.disabled = false;
        }

        function endPlayerTurn() {
            if (isMultiplayer) { endPlayerTurnMP(); return; }
            if (gameIsOver || !isPlayerTurn || !playerHasDrawn) return;
            if (playerStatus.extraTurn) {
                delete playerStatus.extraTurn;
                showMessage("Time Warp! You get another turn.");
                isPlayerTurn = true; actionCardPlayedThisTurn = false; playerHasDrawn = false;
                deckEl.classList.remove('disabled'); endTurnBtn.disabled = true;
                updateHandUI();
                processTurnStartEffects(true);
                return;
            }
            isPlayerTurn = false;
            endTurnBtn.disabled = true;
            showMessage("Opponent's turn.");
            updateHandUI();
            setTimeout(aiTurn, 1000);
        }

        function aiTurn() {
            if (gameIsOver) return;
            processTurnStartEffects(false);
            if (gameIsOver) return;
            let cardToPlay = aiHand.find(c => c.action === 'shield' && aiScore > 15) || aiHand.find(c => c.type === 'attack' && playerScore > 15) || aiHand.find(c => c.action === 'surge' && aiScore < 10) || aiHand.find(c => c.action === 'doubledraw' && aiHand.length < 2);
            if (cardToPlay) { executeAction(cardToPlay, false); aiHand.splice(aiHand.indexOf(cardToPlay), 1); }
            setTimeout(() => {
                if (gameIsOver) return;
                const draws = aiStatus.doubledraw ? 2 : 1;
                if(aiStatus.doubledraw) delete aiStatus.doubledraw;
                forceDraw(false, draws);
                setTimeout(() => {
                    if (gameIsOver) return;
                    isPlayerTurn = true;
                    actionCardPlayedThisTurn = false; playerHasDrawn = false;
                    deckEl.classList.remove('disabled');
                    endTurnBtn.disabled = true;
                    showMessage("Your turn. Draw a card or play an action.");
                    updateHandUI();
                    processTurnStartEffects(true);
                }, 1000 * draws);
            }, 1000);
        }

        async function returnToMenu() {
            if (isMultiplayer && isHost && currentGameId) {
                try { await deleteDoc(doc(db, 'games', currentGameId)); } 
                catch (e) { console.error("Error deleting game doc:", e); }
            }
            if (unsubscribeFromGame) { unsubscribeFromGame(); unsubscribeFromGame = null; }
            isMultiplayer = false; isHost = false; currentGameId = null;
            sideGlossaryEl.classList.remove('open');
            glossaryToggleBtn.classList.remove('open');
            showScreen('menu');
        }

        // --- FIREBASE MULTIPLAYER FUNCTIONS ---
        async function hostGame(mode) {
            if (!auth.currentUser) { hostStatus.textContent = "Error: Not connected."; return; }
            isHost = true; isMultiplayer = true; currentGamemode = mode;
            const hostId = auth.currentUser.uid;
            const gameId = `game-${Date.now()}`;
            const gameRef = doc(db, 'games', gameId);
            currentGameId = gameId;
            createDeck(mode);
            const initialGameState = {
                gameId: currentGameId,
                hostId: hostId,
                hostUsername: currentUserProfile?.username || "Anonymous",
                guestId: null,
                guestUsername: null,
                status: 'waiting',
                winner: null,
                mode: mode,
                deck: deck,
                player1Score: 0, player2Score: 0,
                player1Hand: [], player2Hand: [],
                player1Status: {}, player2Status: {},
                turn: 'player1',
                player1HasDrawn: false, player2HasDrawn: false,
                player1ActionPlayed: false, player2ActionPlayed: false,
                lastAction: { player: 'system', message: 'Game created.' },
                createdAt: serverTimestamp()
            };
            try {
                await setDoc(gameRef, initialGameState);
                hostIdDisplay.textContent = currentGameId;
                hostStatus.textContent = 'Waiting for opponent...';
                listenToGameUpdates(currentGameId);
            } catch (error) {
                console.error("Failed to host game:", error);
                hostStatus.textContent = "Error creating game.";
            }
        }

        async function joinGame(gameId) {
            if (!auth.currentUser) { multiplayerStatus.textContent = "Error: Not connected."; return; }
            const guestId = auth.currentUser.uid;
            const gameRef = doc(db, "games", gameId);
            try {
                multiplayerStatus.textContent = "Connecting...";
                const gameDoc = await getDoc(gameRef);
                if (gameDoc.exists() && gameDoc.data().status === 'waiting' && !gameDoc.data().guestId) {
                    await updateDoc(gameRef, { 
                        guestId: guestId, 
                        guestUsername: currentUserProfile?.username || "Anonymous",
                        status: 'active' 
                    });
                    isHost = false; isMultiplayer = true; currentGameId = gameId;
                    listenToGameUpdates(gameId);
                } else {
                    multiplayerStatus.textContent = "Game not found or is full.";
                }
            } catch (error) {
                console.error("Failed to join game:", error);
                multiplayerStatus.textContent = "Error joining game.";
            }
        }

        function listenToGameUpdates(gameId) {
            const gameRef = doc(db, 'games', gameId);
            if (unsubscribeFromGame) unsubscribeFromGame();
            unsubscribeFromGame = onSnapshot(gameRef, (doc) => {
                const gameData = doc.data();
                gameDataForStats = gameData;
                if (!gameData) { showMessage("The game has ended.", "system"); returnToMenu(); return; }
                if (gameData.status === 'active' && !screens.game.classList.contains('active')) { startGame(gameData.mode, true); }
                
                const myPlayerNumber = isHost ? '1' : '2';
                playerNameDisplay.textContent = isHost ? (gameData.hostUsername || "Host") : (gameData.guestUsername || "Guest");
                opponentNameDisplay.textContent = isHost ? (gameData.guestUsername || "Guest") : (gameData.hostUsername || "Host");

                playerScore = gameData[`player${myPlayerNumber}Score`];
                aiScore = gameData[`player${isHost ? '2' : '1'}Score`];
                playerHand = gameData[`player${myPlayerNumber}Hand`];
                aiHand = gameData[`player${isHost ? '2' : '1'}Hand`];
                playerStatus = gameData[`player${myPlayerNumber}Status`];
                aiStatus = gameData[`player${isHost ? '2' : '1'}Status`];
                deck = gameData.deck;
                isPlayerTurn = (isHost && gameData.turn === 'player1') || (!isHost && gameData.turn === 'player2');
                playerHasDrawn = gameData[`player${myPlayerNumber}HasDrawn`];
                actionCardPlayedThisTurn = gameData[`player${myPlayerNumber}ActionPlayed`];
                
                updateAllUI();

                if (gameData.status === 'finished') {
                    if (gameIsOver) return;
                    const winnerMsg = gameData.winner === myPlayerNumber ? "You Win!" : "You Lose!";
                    showMessage(winnerMsg, "system");
                    endGame(gameData.winner);
                } else {
                    let finalMessage = isPlayerTurn ? "Your turn." : "Opponent's turn.";
                    const lastAction = gameData.lastAction;
                    if (lastAction && lastAction.message) {
                        if (lastAction.player === 'system') {
                            finalMessage = lastAction.message;
                        } else {
                            const actionTaker = lastAction.player === myPlayerNumber ? "You" : "Opponent";
                            finalMessage = `${actionTaker} ${lastAction.message}`;
                        }
                    }
                    showMessage(finalMessage);

                }
                endTurnBtn.disabled = !isPlayerTurn || !playerHasDrawn;
                deckEl.classList.toggle('disabled', !isPlayerTurn || playerHasDrawn);
                deckEl.style.display = 'flex';
            });
        }

        async function updateFirestoreGame(updatedData) {
            if (gameIsOver) return;
            const gameRef = doc(db, 'games', currentGameId);
            try { await updateDoc(gameRef, updatedData); } 
            catch (error) { console.error("Failed to update game state:", error); }
        }

        async function playerDrawsMP() {
            if (!isPlayerTurn || playerHasDrawn) return;
            const myPlayerNumber = isHost ? '1' : '2';
            const gameRef = doc(db, 'games', currentGameId);
            try {
                const gameDoc = await getDoc(gameRef);
                if (!gameDoc.exists()) return;
                const gameData = gameDoc.data();
                let currentDeck = [...gameData.deck];
                let myCurrentHand = [...gameData[`player${myPlayerNumber}Hand`]];
                let myCurrentScore = gameData[`player${myPlayerNumber}Score`];
                let myCurrentStatus = {...gameData[`player${myPlayerNumber}Status`]};
                const draws = myCurrentStatus.doubledraw ? 2 : 1;
                if (myCurrentStatus.doubledraw) delete myCurrentStatus.doubledraw;
                let logMessages = [];
                for (let i = 0; i < draws; i++) {
                    if (currentDeck.length === 0) { logMessages.push('Deck is empty!'); break; }
                    const card = currentDeck.pop();
                    if (card.type === 'aether-shard') {
                        myCurrentScore += card.value;
                        logMessages.push(`drew an Aether Shard (${card.value}).`);
                    } else {
                        if (myCurrentHand.length < handSizeLimit) {
                            myCurrentHand.push(card);
                            logMessages.push(`drew ${card.name}.`);
                        } else {
                            logMessages.push(`drew ${card.name}, but hand was full!`);
                        }
                    }
                }
                if (myCurrentScore > 21) {
                    if (myCurrentStatus.stabilized) {
                        myCurrentScore = 15; delete myCurrentStatus.stabilized;
                        logMessages.push('Stabilizer absorbed the shock!');
                    } else {
                        myCurrentScore = 0;
                        logMessages.push('Rift destabilized! Score reset.');
                    }
                }
                const updates = {
                    deck: currentDeck,
                    [`player${myPlayerNumber}Hand`]: myCurrentHand,
                    [`player${myPlayerNumber}Score`]: myCurrentScore,
                    [`player${myPlayerNumber}Status`]: myCurrentStatus,
                    [`player${myPlayerNumber}HasDrawn`]: true,
                    lastAction: { player: myPlayerNumber, message: logMessages.join(' ') }
                };
                if (myCurrentScore === 21) { updates.status = 'finished'; updates.winner = myPlayerNumber; }
                await updateDoc(gameRef, updates);
            } catch (error) { console.error("Error drawing card in multiplayer:", error); }
        }
        
        async function playActionCardMP(card, index) {
            if (gameIsOver || !isPlayerTurn || actionCardPlayedThisTurn || card.type === 'aether-shard') return;
            const myPlayerNumber = isHost ? '1' : '2';
            const opponentPlayerNumber = isHost ? '2' : '1';
            const gameRef = doc(db, 'games', currentGameId);
            try {
                const gameDoc = await getDoc(gameRef);
                if (!gameDoc.exists()) return;
                const gameData = gameDoc.data();
                let updates = { [`player${myPlayerNumber}ActionPlayed`]: true, lastAction: { player: myPlayerNumber, message: `played ${card.name}!` } };
                let myHand = [...gameData[`player${myPlayerNumber}Hand`]];
                myHand.splice(index, 1);
                updates[`player${myPlayerNumber}Hand`] = myHand;
                let myScore = gameData[`player${myPlayerNumber}Score`];
                let opScore = gameData[`player${opponentPlayerNumber}Score`];
                let myStatus = { ...gameData[`player${myPlayerNumber}Status`] };
                let opStatus = { ...gameData[`player${opponentPlayerNumber}Status`] };
                let opHand = [...gameData[`player${opponentPlayerNumber}Hand`]];
                switch(card.action) {
                    case 'attack': if (opStatus.shield) { delete opStatus.shield; } else { opScore = Math.max(0, opScore - card.value); } break;
                    case 'shatter': if (opStatus.shield) { delete opStatus.shield; } else { opScore = Math.max(0, opScore - 7); } break;
                    case 'swap': [myScore, opScore] = [opScore, myScore]; break;
                    case 'leach': const stolen = Math.min(opScore, card.value); opScore = Math.max(0, opScore - stolen); myScore += stolen; break;
                    case 'doubledraw': myStatus.doubledraw = true; break;
                    case 'shield': myStatus.shield = true; break;
                    case 'stabilize': myStatus.stabilized = true; break;
                    case 'siphon': if (opHand.length > 0) { const stolenCard = opHand.splice(Math.floor(Math.random() * opHand.length), 1)[0]; if (myHand.length < handSizeLimit) myHand.push(stolenCard); } else { opScore = Math.max(0, opScore - 5); } break;
                }
                updates[`player${myPlayerNumber}Hand`] = myHand;
                updates[`player${myPlayerNumber}Score`] = myScore;
                updates[`player${opponentPlayerNumber}Score`] = opScore;
                updates[`player${myPlayerNumber}Status`] = myStatus;
                updates[`player${opponentPlayerNumber}Status`] = opStatus;
                updates[`player${opponentPlayerNumber}Hand`] = opHand;
                if (updates[`player${myPlayerNumber}Score`] > 21) { updates[`player${myPlayerNumber}Score`] = 0; }
                if (updates[`player${opponentPlayerNumber}Score`] > 21) { updates[`player${opponentPlayerNumber}Score`] = 0; }
                if (updates[`player${myPlayerNumber}Score`] === 21) { updates.status = 'finished'; updates.winner = myPlayerNumber;
                } else if (updates[`player${opponentPlayerNumber}Score`] === 21) { updates.status = 'finished'; updates.winner = opponentPlayerNumber; }
                await updateDoc(gameRef, updates);
            } catch (error) { console.error("Error playing multiplayer card:", error); }
        }

        function endPlayerTurnMP() {
            if (!isPlayerTurn || !playerHasDrawn) return;
            const myPlayerNumber = isHost ? '1' : '2';
            const nextTurnPlayer = isHost ? 'player2' : 'player1';
            updateFirestoreGame({ 
                turn: nextTurnPlayer,
                [`player${isHost ? '2':'1'}HasDrawn`]: false,
                [`player${isHost ? '2':'1'}ActionPlayed`]: false,
                lastAction: { player: myPlayerNumber, message: 'ended the turn.' }
            });
        }

        // --- EVENT LISTENERS ---
        singlePlayerBtn.addEventListener('click', () => { isMultiplayer = false; isHost = false; showScreen('gamemode'); });
        multiplayerBtn.addEventListener('click', () => { showScreen('multiplayer'); });
        fullGlossaryBtn.addEventListener('click', () => { populateFullGlossary(); showScreen('fullGlossary'); });
        closeFullGlossaryBtn.addEventListener('click', () => showScreen('menu'));
        hostGameBtn.addEventListener('click', () => { isMultiplayer = true; isHost = true; hostIdDisplay.textContent = 'Generating ID...'; hostStatus.textContent = ''; showScreen('gamemode'); });
        joinGameScreenBtn.addEventListener('click', () => { isMultiplayer = true; isHost = false; multiplayerStatus.textContent = ''; peerIdInput.value = ''; showScreen('join'); });
        connectBtn.addEventListener('click', () => { const gameId = peerIdInput.value.trim(); if (gameId) { joinGame(gameId); } else { multiplayerStatus.textContent = 'Please enter a valid Game ID.'; } });
        hostIdDisplay.addEventListener('click', () => { if (hostIdDisplay.textContent.includes('...')) return; navigator.clipboard.writeText(hostIdDisplay.textContent).then(() => { hostStatus.textContent = 'ID Copied!'; setTimeout(() => { if(hostStatus.textContent === 'ID Copied!') { hostStatus.textContent = 'Waiting for opponent...'; } }, 2000); }); });
        backToMenuBtn.addEventListener('click', () => showScreen('menu'));
        backToMultiplayerMenuBtn.addEventListener('click', () => showScreen('multiplayer'));
        cancelHostBtn.addEventListener('click', returnToMenu);
        gamemodeBackBtn.addEventListener('click', () => { if (isMultiplayer) { showScreen('multiplayer'); } else { showScreen('menu'); } });
        gamemodeButtonsContainer.addEventListener('click', (event) => { const clickedButton = event.target.closest('.gamemode-button'); if (!clickedButton) return; const mode = clickedButton.dataset.mode; if (!mode) return; if (isMultiplayer && isHost) { showScreen('host'); hostGame(mode); } else { startGame(mode, false); } });
        deckEl.addEventListener('click', playerDraws);
        endTurnBtn.addEventListener('click', endPlayerTurn);
        quitGameBtn.addEventListener('click', returnToMenu);
        playAgainBtn.addEventListener('click', () => startGame(currentGamemode, false));
        mainMenuBtn.addEventListener('click', returnToMenu);
        glossaryToggleBtn.addEventListener('click', () => { const isOpen = sideGlossaryEl.classList.toggle('open'); glossaryToggleBtn.classList.toggle('open', isOpen); gameContainer.classList.toggle('menu-open', isOpen); });
        
        signupForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const username = signupForm['signup-username'].value;
            const email = signupForm['signup-email'].value;
            const password = signupForm['signup-password'].value;
            signupError.textContent = '';
            try {
                const userCredential = await createUserWithEmailAndPassword(auth, email, password);
                await createUserDocument(userCredential.user, username);
                // onAuthStateChanged will handle UI update and navigation
            } catch (error) {
                signupError.textContent = error.message;
            }
        });

        loginForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const email = loginForm['login-email'].value;
            const password = loginForm['login-password'].value;
            loginError.textContent = '';
            try {
                await signInWithEmailAndPassword(auth, email, password);
                // onAuthStateChanged will handle UI update and navigation
            } catch (error) {
                loginError.textContent = error.message;
            }
        });

        signupBackBtn.addEventListener('click', () => showScreen('menu'));
        loginBackBtn.addEventListener('click', () => showScreen('menu'));
        statsBackBtn.addEventListener('click', () => showScreen('menu'));

        // --- INITIALIZATION FLOW ---
        function initializeFirebase() {
            multiplayerBtn.disabled = true;
            connectionStatusEl.textContent = "Connecting to multiplayer service...";
            try {
                const firebaseConfig = {
                    apiKey: "AIzaSyDJ8P56QstubpWiZqe7epUpilspua_x8bA",
                    authDomain: "aether-wars-game.firebaseapp.com",
                    projectId: "aether-wars-game",
                    storageBucket: "aether-wars-game.appspot.com",
                    messagingSenderId: "1068965640026",
                    appId: "1:1068965640026:web:3700cd66f2c2b26aa7e563"
                };
                const app = initializeApp(firebaseConfig);
                auth = getAuth(app);
                db = getFirestore(app);

                onAuthStateChanged(auth, async (user) => {
                    const onAuthScreen = screens.login.classList.contains('active') || screens.signup.classList.contains('active');

                    if (user) {
                        await updateAccountUI(user);
                        if (!user.isAnonymous && onAuthScreen) {
                            showScreen('menu');
                        }
                    } else {
                        signInAnonymously(auth).catch(error => console.error("Anonymous sign-in failed:", error));
                    }
                    
                    multiplayerBtn.disabled = false;
                    connectionStatusEl.textContent = "";
                });
                
            } catch (e) {
                console.error("Firebase initialization failed:", e);
                connectionStatusEl.textContent = "Multiplayer offline.";
                multiplayerBtn.disabled = true;
            }
        }

        initializeFirebase();
        showScreen('menu');
    });

</script>
</body>
</html>